name: CI/CD Pipeline

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      business: ${{ steps.changes.outputs.business }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            business:
              - 'services/business/**'

  test:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.business == 'true'
    
    strategy:
      matrix:
        python-version: [3.11]

    steps:
    - uses: actions/checkout@v4

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'poetry'

    - name: Install dependencies
      run: poetry install

    - name: Run linting
      run: |
        poetry run black --check .
        poetry run flake8 .

    - name: Run tests
      run: |
        poetry run pytest -v

  build-and-push:
    runs-on: ubuntu-latest
    needs: [detect-changes, test]
    if: needs.detect-changes.outputs.business == 'true' && github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-

    - name: Build and push Backend image
      uses: docker/build-push-action@v5
      with:
        context: ./services/business/backend
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push Frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./services/business/frontend
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.business == 'true' && github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Add server to known hosts
      run: |
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: Create .env file
      run: |
        cat > .env << EOF
        DATABASE_URL=${{ secrets.DATABASE_URL }}
        SECRET_KEY=${{ secrets.SECRET_KEY }}
        POSTGRES_DB=${{ secrets.POSTGRES_DB }}
        POSTGRES_USER=${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        EXTERNAL_API_KEY=${{ secrets.EXTERNAL_API_KEY }}
        EXTERNAL_API_URL=${{ secrets.EXTERNAL_API_URL }}
        SENTRY_DSN=${{ secrets.SENTRY_DSN }}
        ENVIRONMENT=production
        GITHUB_SHA=${{ github.sha }}
        EOF

    - name: Copy files to server
      run: |
        scp -r ./services/business/ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/${{ secrets.SERVER_USER }}/deployments/
        scp .env ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/${{ secrets.SERVER_USER }}/deployments/business/
        scp ./scripts/*.sh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/home/${{ secrets.SERVER_USER }}/deployments/business/

    - name: Deploy with Blue-Green strategy
      run: |
        ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd /home/${{ secrets.SERVER_USER }}/deployments/business
          
          # 현재 활성 환경 확인
          if docker ps | grep -q "business-backend-blue"; then
            CURRENT_ENV="blue"
            NEW_ENV="green"
            NEW_BACKEND_PORT="8002"
            NEW_FRONTEND_PORT="8503"
          else
            CURRENT_ENV="green" 
            NEW_ENV="blue"
            NEW_BACKEND_PORT="8000"
            NEW_FRONTEND_PORT="8501"
          fi
          
          echo "Current environment: $CURRENT_ENV"
          echo "Deploying to: $NEW_ENV"
          
          # Docker 이미지 태그 업데이트
          sed -i "s/image: ghcr.io\/.*-backend:.*/image: ghcr.io\/${{ github.repository }}-backend:${{ github.sha }}/g" compose/docker-compose.$NEW_ENV.yml
          sed -i "s/image: ghcr.io\/.*-frontend:.*/image: ghcr.io\/${{ github.repository }}-frontend:${{ github.sha }}/g" compose/docker-compose.$NEW_ENV.yml
          
          # 새 환경 배포
          docker-compose -f compose/docker-compose.$NEW_ENV.yml pull
          docker-compose -f compose/docker-compose.$NEW_ENV.yml up -d
          
          # 헬스체크
          echo "Waiting for services to be healthy..."
          sleep 30
          
          # 백엔드 헬스체크
          for i in {1..30}; do
            if curl -f http://localhost:$NEW_BACKEND_PORT/health; then
              echo "Backend health check passed"
              break
            fi
            echo "Backend health check failed, retrying in 10 seconds..."
            sleep 10
          done
          
          # 프론트엔드 헬스체크  
          for i in {1..30}; do
            if curl -f http://localhost:$NEW_FRONTEND_PORT/_stcore/health; then
              echo "Frontend health check passed"
              break
            fi
            echo "Frontend health check failed, retrying in 10 seconds..."
            sleep 10
          done
          
          # Nginx 설정 업데이트 (백업 서버를 새 환경으로 변경)
          if [ "$NEW_ENV" = "blue" ]; then
            sed -i 's/server business-backend-green:8000 max_fails=3 fail_timeout=30s backup;/server business-backend-blue:8000 max_fails=3 fail_timeout=30s;/' nginx/nginx.conf
            sed -i 's/server business-backend-blue:8000 max_fails=3 fail_timeout=30s;/server business-backend-green:8000 max_fails=3 fail_timeout=30s backup;/' nginx/nginx.conf
            sed -i 's/server business-frontend-green:8501 max_fails=3 fail_timeout=30s backup;/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s;/' nginx/nginx.conf
            sed -i 's/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s;/server business-frontend-green:8501 max_fails=3 fail_timeout=30s backup;/' nginx/nginx.conf
          else
            sed -i 's/server business-backend-blue:8000 max_fails=3 fail_timeout=30s;/server business-backend-green:8000 max_fails=3 fail_timeout=30s;/' nginx/nginx.conf
            sed -i 's/server business-backend-green:8000 max_fails=3 fail_timeout=30s backup;/server business-backend-blue:8000 max_fails=3 fail_timeout=30s backup;/' nginx/nginx.conf
            sed -i 's/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s;/server business-frontend-green:8501 max_fails=3 fail_timeout=30s;/' nginx/nginx.conf
            sed -i 's/server business-frontend-green:8501 max_fails=3 fail_timeout=30s backup;/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s backup;/' nginx/nginx.conf
          fi
          
          # Nginx 재로드
          docker exec business-nginx nginx -s reload
          
          # 이전 환경 정리 (30초 후)
          sleep 30
          docker-compose -f compose/docker-compose.$CURRENT_ENV.yml down
          
          # 사용하지 않는 Docker 이미지 정리
          docker image prune -f
          
          echo "Deployment completed successfully!"
        EOF

## 10. 배포 스크립트

### 10.1 배포 스크립트 (scripts/deploy.sh)
```bash
#!/bin/bash

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 로그 함수
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 설정
SERVICE_NAME="business"
DEPLOY_DIR="/home/$(whoami)/deployments/${SERVICE_NAME}"
COMPOSE_DIR="${DEPLOY_DIR}/compose"
NGINX_CONTAINER="business-nginx"

# 함수: 현재 활성 환경 확인
get_current_environment() {
    if docker ps --format "table {{.Names}}" | grep -q "${SERVICE_NAME}-backend-blue"; then
        echo "blue"
    elif docker ps --format "table {{.Names}}" | grep -q "${SERVICE_NAME}-backend-green"; then
        echo "green"  
    else
        echo "none"
    fi
}

# 함수: 헬스체크
health_check() {
    local environment=$1
    local backend_port=$2
    local frontend_port=$3
    local max_attempts=30
    local attempt=0

    log_info "Starting health check for $environment environment..."

    # 백엔드 헬스체크
    while [ $attempt -lt $max_attempts ]; do
        if curl -f -s "http://localhost:${backend_port}/health" > /dev/null; then
            log_info "Backend health check passed"
            break
        fi
        attempt=$((attempt + 1))
        log_warn "Backend health check failed (attempt $attempt/$max_attempts), retrying in 10 seconds..."
        sleep 10
    done

    if [ $attempt -eq $max_attempts ]; then
        log_error "Backend health check failed after $max_attempts attempts"
        return 1
    fi

    # 프론트엔드 헬스체크
    attempt=0
    while [ $attempt -lt $max_attempts ]; do
        if curl -f -s "http://localhost:${frontend_port}/_stcore/health" > /dev/null; then
            log_info "Frontend health check passed"
            return 0
        fi
        attempt=$((attempt + 1))
        log_warn "Frontend health check failed (attempt $attempt/$max_attempts), retrying in 10 seconds..."
        sleep 10
    done

    log_error "Frontend health check failed after $max_attempts attempts"
    return 1
}

# 함수: Nginx 설정 업데이트
update_nginx_config() {
    local new_environment=$1
    
    log_info "Updating Nginx configuration for $new_environment environment..."
    
    if [ "$new_environment" = "blue" ]; then
        # Blue를 활성화, Green을 백업으로 설정
        docker exec $NGINX_CONTAINER sed -i 's/server business-backend-green:8000 max_fails=3 fail_timeout=30s;/server business-backend-green:8000 max_fails=3 fail_timeout=30s backup;/' /etc/nginx/nginx.conf
        docker exec $NGINX_CONTAINER sed -i 's/server business-backend-blue:8000 max_fails=3 fail_timeout=30s backup;/server business-backend-blue:8000 max_fails=3 fail_timeout=30s;/' /etc/nginx/nginx.conf
        docker exec $NGINX_CONTAINER sed -i 's/server business-frontend-green:8501 max_fails=3 fail_timeout=30s;/server business-frontend-green:8501 max_fails=3 fail_timeout=30s backup;/' /etc/nginx/nginx.conf  
        docker exec $NGINX_CONTAINER sed -i 's/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s backup;/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s;/' /etc/nginx/nginx.conf
    else
        # Green을 활성화, Blue를 백업으로 설정
        docker exec $NGINX_CONTAINER sed -i 's/server business-backend-blue:8000 max_fails=3 fail_timeout=30s;/server business-backend-blue:8000 max_fails=3 fail_timeout=30s backup;/' /etc/nginx/nginx.conf
        docker exec $NGINX_CONTAINER sed -i 's/server business-backend-green:8000 max_fails=3 fail_timeout=30s backup;/server business-backend-green:8000 max_fails=3 fail_timeout=30s;/' /etc/nginx/nginx.conf
        docker exec $NGINX_CONTAINER sed -i 's/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s;/server business-frontend-blue:8501 max_fails=3 fail_timeout=30s backup;/' /etc/nginx/nginx.conf
        docker exec $NGINX_CONTAINER sed -i 's/server business-frontend-green:8501 max_fails=3 fail_timeout=30s backup;/server business-frontend-green:8501 max_fails=3 fail_timeout=30s;/' /etc/nginx/nginx.conf
    fi
    
    # Nginx 설정 재로드
    docker exec $NGINX_CONTAINER nginx -t && docker exec $NGINX_CONTAINER nginx -s reload
    log_info "Nginx configuration updated and reloaded successfully"
}

# 메인 배포 로직
main() {
    log_info "Starting Blue-Green deployment for $SERVICE_NAME service..."
    
    cd $DEPLOY_DIR
    
    # 현재 환경 확인
    current_env=$(get_current_environment)
    
    if [ "$current_env" = "blue" ]; then
        new_env="green"
        new_backend_port="8002"
        new_frontend_port="8503"
    elif [ "$current_env" = "green" ]; then
        new_env="blue" 
        new_backend_port="8000"
        new_frontend_port="8501"
    else
        # 초기 배포인 경우 blue 환경으로 시작
        current_env="none"
        new_env="blue"
        new_backend_port="8000" 
        new_frontend_port="8501"
        
        # 기본 인프라 시작 (DB, Redis, Nginx)
        log_info "Starting infrastructure services..."
        docker-compose -f compose/docker-compose.yml up -d postgres redis nginx
        sleep 10
    fi
    
    log_info "Current environment: $current_env"
    log_info "Deploying to: $new_env"
    
    # 새 환경에 배포
    log_info "Pulling latest images..."
    docker-compose -f compose/docker-compose.${new_env}.yml pull
    
    log_info "Starting $new_env environment..."
    docker-compose -f compose/docker-compose.${new_env}.yml up -d
    
    # 서비스 시작 대기
    sleep 30
    
    # 헬스체크 수행
    if ! health_check $new_env $new_backend_port $new_frontend_port; then
        log_error "Health check failed for $new_env environment"
        log_info "Rolling back..."
        docker-compose -f compose/docker-compose.${new_env}.yml down
        exit 1
    fi
    
    # Nginx 설정 업데이트 (트래픽 전환)
    update_nginx_config $new_env
    
    # 이전 환경 정리 (초기 배포가 아닌 경우)
    if [ "$current_env" != "none" ]; then
        log_info "Cleaning up $current_env environment..."
        sleep 30  # 트래픽 전환 후 안전 대기 시간
        docker-compose -f compose/docker-compose.${current_env}.yml down
    fi
    
    # 사용하지 않는 Docker 이미지 정리
    log_info "Cleaning up unused Docker images..."
    docker image prune -f
    
    log_info "Deployment completed successfully! Active environment: $new_env"
}

# 스크립트 실행
main "$@"